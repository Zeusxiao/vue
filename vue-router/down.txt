<div class="a1"> <h1>Global Config</h1> <p>Vue.config is an object containing Vue’s global configurations. You can modify its properties listed below before bootstrapping your application:</p> </div> <div class="a2"> <h2>errorHandler</h2> <ul> <li> <p>Type: Function</p> </li> <li> <p>Default: undefined</p> </li> <li> <p>Usage:</p> </li> </ul> <pre><div class="hljs"><code class="lang-js">Vue.config.errorHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, vm, info</span>) </span>{ <span class="hljs-comment">// handle error</span> <span class="hljs-comment">// `info` is a Vue-specific error info, e.g. which lifecycle hook</span> <span class="hljs-comment">// the error was found in. Only available in 2.2.0+</span> } </code></div></pre> <blockquote> <p>In 2.2.0+, this hook also captures errors in component lifecycle hooks. Also, when this hook is undefined, captured errors will be logged with console.error instead of crashing the app.<br /> In 2.4.0+ this hook also captures errors thrown inside Vue custom event handlers.<br /> Error tracking services Sentry and Bugsnag provide official integrations using this option.</p> </blockquote> </div> <div class="a3"> <h2>keyCodes</h2> <ul> <li> <p>Type: { [key: string]: number | Array<number> }</p> </li> <li> <p>Default: {}</p> </li> <li> <p>Usage:</p> </li> </ul> <pre><div class="hljs"><code class="lang-js">Vue.config.keyCodes = { <span class="hljs-attr">v</span>: <span class="hljs-number">86</span>, <span class="hljs-attr">f1</span>: <span class="hljs-number">112</span>, <span class="hljs-comment">// camelCase won`t work</span> mediaPlayPause: <span class="hljs-number">179</span>, <span class="hljs-comment">// instead you can use kebab-case with double quotation marks</span> <span class="hljs-string">"media-play-pause"</span>: <span class="hljs-number">179</span>, <span class="hljs-attr">up</span>: [<span class="hljs-number">38</span>, <span class="hljs-number">87</span>] } </code></div></pre> <pre><div class="hljs"><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> @<span class="hljs-attr">keyup.media-play-pause</span>=<span class="hljs-string">"method"</span>&gt;</span> </code></div></pre> <h6>Define custom key alias(es) for v-on.</h6> </div> <div class="a4"> <h1>Options / Data</h1> </div> <div class="a5"> <h2>props</h2> <ul> <li> <p>Type: Array<string> | Object</p> </li> <li> <p>Details:</p> </li> </ul> <h6>A list/hash of attributes that are exposed to accept data from the parent component. It has an Array-based simple syntax and an alternative Object-based syntax that allows advanced configurations such as type checking, custom validation and default values.</h6> <ul> <li>Example:</li> </ul> <pre><div class="hljs"><code class="lang-js"><span class="hljs-comment">// simple syntax</span> Vue.component(<span class="hljs-string">'props-demo-simple'</span>, { <span class="hljs-attr">props</span>: [<span class="hljs-string">'size'</span>, <span class="hljs-string">'myMessage'</span>] }) <span class="hljs-comment">// object syntax with validation</span> Vue.component(<span class="hljs-string">'props-demo-advanced'</span>, { <span class="hljs-attr">props</span>: { <span class="hljs-comment">// type check</span> height: <span class="hljs-built_in">Number</span>, <span class="hljs-comment">// type check plus other validations</span> age: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">Number</span>, <span class="hljs-attr">default</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">validator</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{ <span class="hljs-keyword">return</span> value &gt;= <span class="hljs-number">0</span> } } } }) </code></div></pre> <ul> <li>See also: Props</li> </ul> </div> <div class="a6"> <h2>computed</h2> <ul> <li> <p>Type: { [key: string]: Function | { get: Function, set: Function } }</p> </li> <li> <p>Details:</p> </li> </ul> <p>Computed properties to be mixed into the Vue instance. All getters and setters have their this context automatically bound to the Vue instance.</p> <blockquote> <p>Note that you should not use an arrow function to define a computed property (e.g. aDouble: () =&gt; this.a * 2). The reason is arrow functions bind the parent context, so this will not be the Vue instance as you expect and this.a will be undefined.</p> </blockquote> <p>Computed properties are cached, and only re-computed on reactive dependency changes. Note that if a certain dependency is out of the instance’s scope (i.e. not reactive), the computed property will not be updated.</p> <ul> <li>Example:</li> </ul> <pre><div class="hljs"><code class="lang-js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({ <span class="hljs-attr">data</span>: { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> }, <span class="hljs-attr">computed</span>: { <span class="hljs-comment">// get only</span> aDouble: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a * <span class="hljs-number">2</span> }, <span class="hljs-comment">// both get and set</span> aPlus: { <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a + <span class="hljs-number">1</span> }, <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v</span>) </span>{ <span class="hljs-keyword">this</span>.a = v - <span class="hljs-number">1</span> } } } }) vm.aPlus <span class="hljs-comment">// =&gt; 2</span> vm.aPlus = <span class="hljs-number">3</span> vm.a <span class="hljs-comment">// =&gt; 2</span> vm.aDouble <span class="hljs-comment">// =&gt; 4</span> </code></div></pre> <ul> <li>See also: Computed Properties</li> </ul> </div> <div class="a7"> <h1>Options / DOM</h1> </div> <div class="a8"> <h2>el</h2> <ul> <li> <p>Type: string | HTMLElement</p> </li> <li> <p>Restriction: only respected in instance creation via new.</p> </li> <li> <p>Details:</p> </li> </ul> <p>Provide the Vue instance an existing DOM element to mount on. It can be a CSS selector string or an actual HTMLElement.</p> <p>After the instance is mounted, the resolved element will be accessible as vm.$el.</p> <p>If this option is available at instantiation, the instance will immediately enter compilation; otherwise, the user will have to explicitly call vm.$mount() to manually start the compilation.</p> <pre><div class="hljs"><code class="lang-html">The provided element merely serves as a mounting point. Unlike in Vue 1.x, the mounted element will be replaced with Vue-generated DOM in all cases. It is therefore not recommended to mount the root instance to <span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span> or <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>. </code></div></pre> <pre><div class="hljs"><code class="lang-html">If neither render function nor template option is present, the in-DOM HTML of the mounting DOM element will be extracted as the template. In this case, Runtime + Compiler build of Vue should be used. </code></div></pre> <ul> <li>See also: <ul> <li>Lifecycle Diagram</li> <li>Runtime + Compiler vs. Runtime-only</li> </ul> </li> </ul> </div> <div class="a9"> <h2>template</h2> <ul> <li> <p>Type: string</p> </li> <li> <p>Details:</p> </li> </ul> <p>A string template to be used as the markup for the Vue instance. The template will replace the mounted element. Any existing markup inside the mounted element will be ignored, unless content distribution slots are present in the template.</p> <p>If the string starts with # it will be used as a querySelector and use the selected element’s innerHTML as the template string. This allows the use of the common <script type="x-template"> trick to include templates.</p> <blockquote> <p>From a security perspective, you should only use Vue templates that you can trust. Never use user-generated content as your template.</p> </blockquote> <blockquote> <p>If render function is present in the Vue option, the template will be ignored.</p> </blockquote> <ul> <li>See also: <ul> <li>Lifecycle Diagram</li> <li>Content Distribution with Slots</li> </ul> </li> </ul> </div>
GitHub